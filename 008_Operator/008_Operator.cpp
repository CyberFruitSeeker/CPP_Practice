#include <iostream>

void Test()
{
    int a = 0;
}

int Plus(int _Left, int _Right)
{
    return _Left + _Right;
}

int main()
{
    Test();
    // 코드 읽기 규칙
    // 1. 기본적으로는 위에서부터 아래로 읽는다.
    // 2. 오른쪽에서 왼쪽으로 읽습니다.
    // 3. 그대신 예외가 있는데 ()

    int Left = 3;
    // 오른쪽에서 왼쪽으로 익는다.
    // 0. 3을 준비한다.
    // 1. 대입연산자를 준비한다.
    // 2. left를 만든다.
    // 3. 대입한다.

    int Right = 5;
    int Result = 0;

    // 변수를 사용해서 특정한 결과를 리턴하는 것을 연산자라고 합니다.
    // 이때 변수가 1개 필요하면
    // 단항 연산자
    // !Left;

    // 이때 변수가 2개 필요하면
    // 이 연산자
    // Left + Right;

    // 이때 변수가 3개 필요하면
    // 삼항연산자 
    // Left == Right ? true : false;
 
    // 연산자의 종류는 다음과 같습니다
    // 1. 산술 연산자
    // 변수의 사용방법은
    // 앞에 자료형이 붙어있으면 만들겠다.
    // 사용할때는 자료형을 생략하고 사용하는것이 맞다.
    // 오른쪽의 메모리를 왼쪽의 메모리로 복사한다.
    // [][][][] [][][][][] [][][][] [][][][][] <= 램의 어딘가?
    //   Left               Right
    // [00000000][00000000][00000000][00001000] [][][][][] [00000000][00000000][00000000][00001000] [][][][][]
    Left = Right;
    // 중단점에 대해서 설명하겠습니다.

    Left = 3;

    // 연산자는 == 함수입니다.
    // 연산자 == 함수 == 행동

    // 연산자는 무조건 같은 자료형끼리로 구성되어있으며
    // 정수 + 정수 = 정수
    Result = Left + Right; // 8
    Result = Plus(Left, Right); // 8
    Result = Left - Right; // -2
    Result = Left * Right; // 15
    Result = Left / Right; // 0
    Result = Left % Right; // 3 // 3을 5로 나누어서 나누지 못하고 남은 수를

    // 논리형 상수는 true와 false가 있습니다.
    // 정수형 상수는? 1 100 100 220 
    bool bResult = false;
    bResult = true;

    // 2. 비교 연산자 & 관계 연산자
    // 비교연산자가 리턴하는건 논리형을 리턴합니다.
    bResult = Left == Right; // Left와 Right가 같아?
                            // 같으면 1 다르면 0을 리턴하게 만들어놨다.
                            // 1과 0 => 정수
                            // 1이나 0같은 정수와
                            // 맞다 혹은 틀리다라는 개념은 똑같이 보면 안된다고 생각해서
                            // 맞다 혹은 틀리다라는 개념을 표현하기 위한 자료형을 아예 따로 만들었습니다.
                            // 그게 bool 자료형 입니다.
                            // 1 바이트 논리형
                            // int => 4바이트 정수
                            // bool => 1바이트 논리형
    bResult = Left != Right;
    bResult = Left > Right;
    bResult = Left < Right;
    bResult = Left >= Right;
    bResult = Left <= Right;

    // 3. 논리연산자
    // 논리연산자를 이해라려면 참과 거짓에 대해서 이해해야합니다.
    //                      맞다와 틀리다.
    // 이걸 이해하려면 비트단위로 자료형을 바라볼수 있어야 합니다.
    // int 4바이트 정수형
    // 00000000 00000000 00000000 00100011
    // 모든 값은 논리형이 될수 있다.
    // 이유는 c++ 코딩에서 참과 거짓 맞다와 틀리다는 아래와 같이 표현되기 때문이다.
    // 참 => 모든 비트중 단 1개라도 1이 있으면 참
    // 거짓 = > 모든 비트가 0이어야 거짓.
    bResult = Left;
    bResult = 0;
    // 오로지 0만이 거짓이고 나머지 모든 숫자는 다 참이다.
    
    // 이걸 이해한 상태로 논리부정
    // 단항 연산자
    // 오른쪽 메모리가 true라면 false을 false이면 true을 리턴합니다.
    bResult = !Left;

    // 논리적 And
    // 왼쪽과 오른쪽 메모리가 참이어야 참을 리턴합니다.
    bResult = Left && Right;
    bResult = false && Right;
    bResult = Left && false;

    // 논리적 Or
    // 왼쪽과 오른쪽 메모리중 1개라도 참이 있으면 참
    bResult = Left || Right;
    bResult = false || Right;
    bResult = Left || false;

    // 4. 비트 연산자
    // 좀더 쉽게 강의하기 위해서 C++버전을 변경할겁니다.
    //                                   8421
    Left = 0b00000000000000000000000000000000;
    //~ 0=> 1 1 => 0
    Left = ~0b00000000000000000000000000000000;
    Left = 0b11111111111111111111111111111111;

    // 수학자들이 만들거라.
    // 가장 앞 비트가 1이면 음수라고 하기로 했습니다
    // 그랬더니 문제가 생겼다. 0에 -0이라는게 없다는 것이다.
    // 2의 보수법이라는 방법을 사용하기로 했습니다.
    // 맨 앞의 비트가 1이되서 음수가 되면
    // 양수표현식에서 뒤집자는 겁니다.
    // 모든 값이 1로 채워졌을때를 -1로 보고
    // -2를 만들고 싶으면 그 -1인 상태에서 0인 곳의 
    // 값을 음수로 더하기로 했다.
    //                                   8421
    //                                           -1 + -1
    Left = 0b11111111111111111111111111111110;
    //       |
    //    부호비트
    // 1. 32번째 비트(부호비트)를 확인한다.
    // 2. 0이다 => 그냥 양수표현식으로 계산.
    // 3. 1이다 => 그럼 음수로 보고 모든 비트가 1일때를 -1로 본다.
    // 4.          그리고 0인부분의 숫자를 음수로 더해준다.
    
    // a & b 비트 and
    // && 왼쪽과 오른쪽을 비교해서 true ture == > true
    Left  = 0b00000000000000000000000000000011;
    Right = 0b00000000000000000000000000000001;
          //0b00000000000000000000000000000001;
    Result = Left & Right;

    // a | b 비트 or
    // || 왼쪽과 오른쪽을 비교해서 하나라도 true가 있으면 true
    Left  = 0b00000000000000000000000000000011;
    Right = 0b00000000000000000000000000000001;
         // 0b00000000000000000000000000000011;
    Result = Left | Right;

    // 배타적 논리합 ^ 
    // 1. 양쪽의 비트가 같으면 0
    // 2. 양쪽의 비트가 다르면 1
    // 3. 위 두가지 조건에 해당하지 않으면 0
    Left  = 0b00000000000000000000000000000011;
    Right = 0b00000000000000000000000000000001;
         // 0b00000000000000000000000000000011;
    Result = Left ^ Right;
    int a = 0;

    Left  = 0b00000000000000000000000000000011;
    Right = 0b00000000000000000000000000000100;
    Result = Left & Right;

    // a << b 비트 시프트

    Left = 0b00000000000000000000000000000001;
    //     0b10000000000000000000000000000000;
    Result = Left << 31;

    Left = 0b00000000000000000000000000000001;
    //     0b00000000000000000000000000000000;
    Result = Left >> 1;

    //  0b11111111111111111111111111111;
    //=>0b01111111111111111111111111111;

    // 비트단위 연산자를 사용해서
    // 양수 최대값.
    // 결과물 => 0b01111111111111111111111111111;
    // 1. 일단 -1을 만드세요.
    // 2. 맨 앞의 부호비트만 0으로 만들면 됩니다.

    // 하드웨어에 따라서 달라지기 때문에
    // 1이 이었어 => 밀어서 끝단까지 가게되면 어떻게 되지?

    // 퀘스트가 10개 있다고 칩시다.
    bool Q0 = true;
    bool Q1 = true;
    bool Q2 = false;
    bool Q3 = false;
    bool Q4 = false;
    bool Q5 = false;
    bool Q6 = false;
    bool Q7 = false;
    bool Q8 = false;
    bool Q9 = false;

    // 5. 복합 할당 연산자
    // 6. 멤버와 포인터 연산자 <= 포인터 배우고 나서 하겠"습니다.
    
    // 7. 기타 연산자 
    {
        // 특정 자료형의 바이트 크기를 확인할수 있는 연산자가 있습니다.
        int Value;
        int IntSize = 0;
        IntSize = sizeof(int);
        IntSize = sizeof(Value);

        int PtrSize = 0;
        PtrSize = sizeof(int*);

        int a = 0;
    }

}
