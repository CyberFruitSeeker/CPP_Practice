// 010_Pointer.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>

// 이건 저의 코딩스탠다드입니다.

void Damage(int _Hp, int _Att)
{
    _Hp = _Hp - _Att;
}

int main()
{
    {
        // 포인터란 무엇이냐?
        // 변수의 주소값을 저장하기 위한 자료형입니다.
        // 주소값이라고 하는것은 무조건 => 정수 0.5바이트 번지?
        // 
        // 포인터는 포인터를 위한 연산자와 문법이 별개로 존재합니다.
        

        // int* 통체로 자료형이라고 합니다.
        // 포인터 문법은 자료형 뒤에 *을 붙이면 뭐든지 그 자료형의 포인터형이 됩니다.
        // 포인터는 굉장히 위험한 점이 많기 때문에.
        // 특정 주소를 담는다. 그래서 일반적인 정수와는 다른 문법들이 많습니다.
        // 어떤 변수나 메모리의 램의 정수 위치;
        // 주소값 자체에는 큰 의미를 두지 마세요.
        // ex) 이게 왜 67억번지에 있지?

        // 포인터는 일반적인 대입이 안된다.
        // 정수라고 해서 정수를 넣어주면 대입이 되는 것이 아니다.
        // 특정 메모리영역의 주소값을 리턴해 달라는 단항연산자.

        // 16진수 표기법입니다.
        //                     101112131415
        // 0 1 2 3 4 5 6 7 8 9 a b c d e f
        // int HexValue = 0x0   0   0   0   0   0   e   5   4   c   0   f   f   7   1   4;
        //                  0000000000000000000000000000000000000000000000000000000000010100
        //              16
        // 2진수 표기법.
        
        // 4바이트 정수

        __int64 Addres000 = 0x00000046104ffa14;
        int BinValue = 0b00000000000000000000000000000000;



        int Value = 0;
        int* ValuePtr = &Value;
        int** ValuePtrPtr = &ValuePtr;

        // Addres000 = ValuePtrPtr;

        int a = 0;
    }

    {
        int MonsterHp = 100;
        Damage(MonsterHp, 10);
    }
}

// 프로그램 실행: <Ctrl+F5> 또는 [디버그] > [디버깅하지 않고 시작] 메뉴
// 프로그램 디버그: <F5> 키 또는 [디버그] > [디버깅 시작] 메뉴

// 시작을 위한 팁: 
//   1. [솔루션 탐색기] 창을 사용하여 파일을 추가/관리합니다.
//   2. [팀 탐색기] 창을 사용하여 소스 제어에 연결합니다.
//   3. [출력] 창을 사용하여 빌드 출력 및 기타 메시지를 확인합니다.
//   4. [오류 목록] 창을 사용하여 오류를 봅니다.
//   5. [프로젝트] > [새 항목 추가]로 이동하여 새 코드 파일을 만들거나, [프로젝트] > [기존 항목 추가]로 이동하여 기존 코드 파일을 프로젝트에 추가합니다.
//   6. 나중에 이 프로젝트를 다시 열려면 [파일] > [열기] > [프로젝트]로 이동하고 .sln 파일을 선택합니다.
